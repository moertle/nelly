include "constants.bnf"

<%pre
    import random
    import struct
    import os
    import hashlib
    import time
    import socket
    import select

    nelly.encode = 'iso-8859-1'

    skt = socket.socket()
    skt.connect(('localhost',4433))

    def c24(sLen):
        (nHigh,nLow) = struct.unpack('!BH', sLen)
        return (nHigh << 16) + nLow

    def _timeout(fd, wait=10.0):
        fds = select.select([fd], [], [], wait)
        return 0 == len(fds[0])

    #try:
    #    import OpenSSL
    #except ImportError:
    #    print('Need Python OpenSSL library')
    #    nelly.bail()

    def dump509(x509):
        x509 = OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_ASN1, x509)
        x509name = x509.get_subject()
        print('[+] X509 Name:',)
        d = {}
        for (sKey,sValue) in x509name.get_components():
            d[sKey] = sValue
        print(d['CN'])
        print()
        pkey = x509.get_pubkey()
        priv_key = OpenSSL.crypto.dump_privatekey(OpenSSL.crypto.FILETYPE_ASN1, pkey)
        nelly.utils.hexdump(priv_key)

    print('[+] Starting')
%>

VERSION: \x03 \x01;

// -----------------------------------------------------------------------------
//
// TYPES FOUND AT BEGINNING OF RECORD
//

TYPE_HANDSHAKE: \x16;
TYPE_CHANGE_CIPHER_SPEC: \x14;

// -----------------------------------------------------------------------------

$TIME: <% $* = int(time.time()) %>;

$PREMASTER
    : VERSION RANDCHAR{46}
    <%
        handshake = b''
        premaster = $$
        $* = b''
    %>
    ;

// -----------------------------------------------------------------------------

SSL_START(start):
    $PREMASTER              // generate the premaster secret
    $SSL_FIRST_PACKET       // then generate the first packet
    $SSL_SECOND_PACKET      // followed by the second packet (brilliant!)
    ;

// -----------------------------------------------------------------------------

$SSL_FIRST_PACKET:
    // the first packet is pretty simple
    ( TYPE_HANDSHAKE VERSION %struct.pack('!H', %len(SSL_CLIENT_HELLO_HDR)) \SSL_CLIENT_HELLO_HDR )
    <%

    serverHelloRandom = None
    x509 = None
    # send it out on the socket
    print('[+] Sending on socket')
    ok = skt.send($$)
    if not ok:
        skt.close()

    shouldQuit = False
    while False == shouldQuit:
        if _timeout(skt):
            break

        # read the first 5 bytes
        sData = skt.recv(5)
        if not sData or 5 != len(sData):
            # XXX: handle this error
            print('[!] Read error from server')
            exit()


        # unpack the data
        (ct,vers,nLen) = struct.unpack('!BHH', sData)
        sData = skt.recv(nLen)

        # is it the right type?
        if ct != 22:
            # XXX: handle this error
            print('[!] Invalid response from server')
            nelly.utils.fail()

        # add it to the handshake data
        handshake += sData

        # parse the data
        while sData:
            nType = sData[0]
            nLen = c24(sData[1:4])
            sData = sData[4:]

            sHello = sData[:nLen]

            # server hello
            if 2 == nType:
                print('[+] Server Hello')
                serverHelloRandom = sHello[2:34]
                nSessLen = sHello[34]
                #sData2 = sHello[35:]

                # SSL Session...
                #self.sSession = sHello[:nSessLen]
                #(nSuite,nComp) = struct.unpack('!HB', sHello[nSessLen:])

            # the X.509 certificate
            elif 11 == nType:
                x509 = sHello[6:]
                print('[+] X509 Cert:', len(x509), 'bytes')
                #dump509(x509)

            # end of records
            elif 14 == nType:
                shouldQuit = True
                break

            sData = sData[nLen:]

    # generate the master and mac

    randstr = premaster + clientHelloRandom + serverHelloRandom
    master  = hashlib.md5(premaster + hashlib.sha1(b'A'   + randstr).digest()).digest()
    master += hashlib.md5(premaster + hashlib.sha1(b'BB'  + randstr).digest()).digest()
    master += hashlib.md5(premaster + hashlib.sha1(b'CCC' + randstr).digest()).digest()

    randstr = master + serverHelloRandom + clientHelloRandom
    writeMAC  = hashlib.md5(master + hashlib.sha1(b'A'   + randstr).digest()).digest()
    writeMAC += hashlib.md5(master + hashlib.sha1(b'BB'  + randstr).digest()).digest()
    writeMAC += hashlib.md5(master + hashlib.sha1(b'CCC' + randstr).digest()).digest()

    print('[+] Done with first packet')
    print()

    $* = ''

    %>
    ;

// -----------------------------------------------------------------------------

$SSL_SECOND_PACKET
    :
    TYPE_HANDSHAKE
    VERSION
    %struct.pack('!H', %len(SSL_CLIENT_KEY_EXCHANGE))
    \SSL_CLIENT_KEY_EXCHANGE

    TYPE_CHANGE_CIPHER_SPEC
    VERSION
    \x00 \x01 \x01

    TYPE_HANDSHAKE
    VERSION
    \x00 \x20

    $SSL_FINISHED_MESSAGE

    <%
    print('[+] GEN...')
    #nelly.utils.hexdump($$)

    exit()

    ok = skt.send($$)
    if not ok:
        skt.close()

    $* = skt.recv(5)
    if $*:
        (ct,vers,nLen) = struct.unpack('!BHH', $*)
        $* += skt.recv(nLen)
        nelly.utils.hexdump($*)

    print('>>>>', len($*))
    %>
    ;

// -----------------------------------------------------------------------------

::SSL_CLIENT_HELLO_HDR:
    // HANDSHAKE_TYPE: Client Hello
    \x01
    // Length of the next section
    %struct.pack('!I', %len(SSL_CLIENT_HELLO))[1:]
    // The next sesction
    \SSL_CLIENT_HELLO
    <%
        handshake += $$
        #print('[+] SSL_CLIENT_HELLO_HDR')
        #nelly.utils.hexdump($$)
    %>
    ;

::SSL_CLIENT_HELLO:
    VERSION
    CLIENT_HELLO_RANDOM_STRING
    \x00                                // Session ID Length

    //\x00 \x02
    //\x00 \x0A

    \x00 \x18                           // Cipher Suites Length
    \x00 \x39
    \x00 \x38
    \x00 \x35
    \x00 \x33
    \x00 \x32
    \x00 \x04
    \x00 \x05
    \x00 \x2f
    \x00 \x16
    \x00 \x13
    \xfe \xff
    \x00 \x0a

    \x01                                // Compression Methods Length
    \x00                                // Compression Method
    ;

CLIENT_HELLO_RANDOM_STRING:
    %struct.pack('!I', $TIME) RANDCHAR{28}
    <% clientHelloRandom = $$ %>
    ;

// -----------------------------------------------------------------------------

SSL_CLIENT_KEY_EXCHANGE:
    \x10                                // HANDSHAKE_TYPE: Client Key Exchange
    %struct.pack('!I', %len(SSL_ENCRYPTED))[1:]
    \SSL_ENCRYPTED
    <%
        handshake += $$
    %>
    ;

// -----------------------------------------------------------------------------

SSL_ENCRYPTED:
    %struct.pack('!H', %len($SSL_ENCRYPTED2))
    \$SSL_ENCRYPTED2
    ;

$SSL_ENCRYPTED2:
    <%
        #print('[+] X509')
        #nelly.utils.hexdump(x509)
        #$* = crypt.rsa_encrypt(x509, premaster)
        $* = 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'
        #nelly.utils.hexdump($*)
    %>
    ;

$SSL_FINISHED_MESSAGE:
    <%
        p1 = b'\x36'
        p2 = b'\x5c'
        sndr = b'CLNT'

        m = hashlib.md5(master  + p2*40 + hashlib.md5(handshake + sndr + master + p1*40).digest()).digest()
        s = hashlib.sha1(master + p2*48 + hashlib.sha1(handshake + sndr + master + p1*48).digest()).digest()

        $* = m + s[:16]

        #print(len(m), len(s))
        #print(':::', `$*`)
        #print()
    %>
    ;

<%post
    print('Closing...')
    skt.close()
    print('[+] Done')
%>
