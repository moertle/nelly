include "constants.bnf"

<%
    import os
    import random
    import struct
    import hashlib
    import logging

    import beaker

    skt = beaker.socket.TcpSocket()

    try:
        port = $port
    except:
        port = 443

    skt.Connect($host, $port)

    logging.debug('Starting...')
%>


$PREMASTER: VERSION  CHAR{46}
    <%
        handshake = ''
        premaster = $$
        $* = ''
    %>;


START(start): $PREMASTER $SSL_FIRST_PACKET $SSL_SECOND_PACKET;


$SSL_FIRST_PACKET:
    TYPE_HANDSHAKE  VERSION  %struct.pack('!H', %len(SSL_CLIENT_HELLO_HDR))  \SSL_CLIENT_HELLO_HDR
    <%

    serverHelloRandom = None
    x509 = None

    # send it out on the socket
    logging.debug('Sending on socket')

    if not skt.Write($$):
        skt.Close()

    quit = False
    while not quit:
        if skt.Timeout(1.0):
            break

        # read the first 5 bytes
        data = skt.Read(5)
        if not data or 5 != len(data):
            # XXX: handle this error
            logging.error('Read error from server')
            fail()

        # unpack the data
        (conntype,vers,length) = struct.unpack('!BHH', data)
        data = skt.Read(length)

        # is it the right type?
        if conntype != 22:
            # XXX: handle this error
            logging.error('Invalid response from server')
            fail()

        # add it to the handshake data
        handshake += data

        # parse the data
        while data:
            cmd = ord(data[0])
            length = struct.unpack('!I', '\x00' + data[1:4])
            data = data[4:]

            hello = data[:length]

            # server hello
            if 2 == cmd:
                logging.debug('Server Hello')

                serverHelloRandom = hello[2:34]
                sessionLength = ord(hello[34])
                #data2 = hello[35:]

                # SSL Session...
                #self.session = hello[:sessionLength]
                #(suite,compression) = struct.unpack('!HB', hello[sessionLength:])

            # X.509 certificate
            elif 11 == cmd:
                x509 = hello[6:]
                logging.debug('X509 Cert %d bytes', len(x509))
                dump509(x509)

            # end
            elif 14 == cmd:
                quit = True
                break

            data = data[length:]

    # generate the master and mac

    rand = premaster + clientHelloRandom + serverHelloRandom
    master  = hashlib.md5(premaster + hashlib.sha1('A'   + rand).digest()).digest()
    master += hashlib.md5(premaster + hashlib.sha1('BB'  + rand).digest()).digest()
    master += hashlib.md5(premaster + hashlib.sha1('CCC' + rand).digest()).digest()

    rand = master + serverHelloRandom + clientHelloRandom
    writeMAC  = hashlib.md5(master + hashlib.sha1('A'   + rand).digest()).digest()
    writeMAC += hashlib.md5(master + hashlib.sha1('BB'  + rand).digest()).digest()
    writeMAC += hashlib.md5(master + hashlib.sha1('CCC' + rand).digest()).digest()

    logging.debug('First packet complete')

    $* = ''

    %>;


$SSL_SECOND_PACKET:
    TYPE_HANDSHAKE
    VERSION
    %struct.pack('!H', %len(SSL_CLIENT_KEY_EXCHANGE))
    \SSL_CLIENT_KEY_EXCHANGE

    TYPE_CHANGE_CIPHER_SPEC
    VERSION
    0x00 0x01 0x01

    TYPE_HANDSHAKE
    VERSION
    0x00 0x20

    $SSL_FINISHED_MESSAGE

    <%
    logging.debug('Generating...')
    hexdump($$)

    fail()


    if not skt.Write($$):
        skt.Close()

    $* = skt.Read(5)
    if $*:
        (conntype,vers,length) = struct.unpack('!BHH', $*)
        $* += skt.Read(length)
        hexdump($*)

    logging.debug('>>> %d', len($*))
    %>;


SSL_CLIENT_HELLO_HDR: 0x01  %struct.pack('!I', %len(SSL_CLIENT_HELLO))[1:]  \SSL_CLIENT_HELLO
    <%
        handshake += $$

        logging.debug('SSL_CLIENT_HELLO')
        hexdump($$)
    %>;


SSL_CLIENT_HELLO:
    VERSION

    CLIENT_HELLO_RANDOM_STRING

    0x00               # Session ID Length

    # 0x00 0x02
    # 0x00 0x0A

    0x00 0x18          # Cipher Suites Length
    0x00 0x39
    0x00 0x38
    0x00 0x35
    0x00 0x33
    0x00 0x32
    0x00 0x04
    0x00 0x05
    0x00 0x2f
    0x00 0x16
    0x00 0x13
    0xfe 0xff
    0x00 0x0a

    0x01               # Compression Methods Length
    0x00               # Compression Method
    ;


CLIENT_HELLO_RANDOM_STRING:
    %struct.pack('!I', %int($TIME)) CHAR{28}
    <%
        clientHelloRandom = $$
    %>;


SSL_CLIENT_KEY_EXCHANGE: 0x10  %struct.pack('!I', %len(SSL_ENCRYPTED))[1:]  \SSL_ENCRYPTED
    <%
        handshake += $$
    %>;


SSL_ENCRYPTED: %struct.pack('!H', %len($SSL_ENCRYPTED2))  \$SSL_ENCRYPTED2;


$SSL_ENCRYPTED2:
    <%
        hexdump(x509)
        #$* = encrypt(x509, premaster)
        $* = 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'
        hexdump($*)
    %>
    ;


$SSL_FINISHED_MESSAGE:
    <%
        logging.debug('Handshake: %d', len(handshake))

        p1 = chr(0x36)
        p2 = chr(0x5c)
        sndr = 'CLNT'
        m = hashlib.md5(master + p2*40 + hashlib.md5(handshake + sndr + master + p1*40).digest()).digest()
        s = hashlib.sha1(master + p2*48 + hashlib.sha1(handshake + sndr + master + p1*48).digest()).digest()

        $* = m + s[:16]

        logging.debug('%d %d', len(m), len(s))
        logging.debug('%s', repr($*))
    %>
    ;

<%
    logging.debug('Closing...')
    skt.Close()
    logging.debug('Done')
%>
